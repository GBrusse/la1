; 'subj' is short for 'subject', 'srch' is short for 'search', and 'repl' is short for 'replacement'
; 'recopy' is a recursive copy function. 'recdel' is a recursive delete function.

(define (replace-random repl)
  (if (null? repl)
      repl
      (let ((random-value (random repl)))
        random-value)))

(define (tsar subj srch repl)
  (cond
    ((null? subj) '())
    ((equal? subj srch) (replace-random repl))
    ((pair? subj) (cons (tsar (car subj) srch repl)
                        (tsar (cdr subj) srch repl)))
    (else subj)))

(define (equal? x y)
  (cond
    ((and (pair? x) (pair? y)) (and (equal? (car x) (car y)) (equal? (cdr x) (cdr y))))
    ((or (pair? x) (pair? y)) #f)
    (else (eq? x y))))

(define (recopy subj)
  (cond
    ((null? subj) '())
    ((pair? subj) (cons (recopy (car subj))
                        (recopy (cdr subj))))
    (else subj)))

(define (recdel subj srch)
  (cond
    ((null? subj) '())
    ((equal? subj srch) '())
    ((pair? subj) (cons (recdel (car subj) srch)
                        (recdel (cdr subj) srch)))
    (else subj)))


#|
Almost there... Fails on (tsar ’(x (x) ((x)) z) ’() ’(y y))
with the error message:
In procedure raise-exception:
In procedure car: Wrong type argument in position 1 (expecting pair): x

?need to add another condition to check if the current subj is a list before accessing its car and cdr?

(define (tsar subj srch repl)
  (cond
    ((null? subj) '())
    ((eq? subj srch)
     (let ((rand-val (random 100)))
       (cond
         ((not (list? repl)) repl)
         ((not (equal? repl '(RANDOM))) repl)
         (else rand-val))))
    ((list? srch)
     (if (equal? subj srch)
         repl
         (cons (tsar (car subj) srch repl) (tsar (cdr subj) srch repl))))
    ((list? subj) (cons (tsar (car subj) srch repl) (tsar (cdr subj) srch repl)))
    (else subj)))
|#
